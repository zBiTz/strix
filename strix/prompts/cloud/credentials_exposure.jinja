<cloud_credentials_exposure_guide>
<title>CLOUD CREDENTIALS EXPOSURE</title>

<critical>Exposed cloud credentials provide immediate unauthorized access to cloud resources. Leaked access keys, service account keys, and tokens in repositories, container images, logs, or environment variables enable attackers to compromise cloud accounts without exploiting any application vulnerability. Detection and validation of credential viability is essential.</critical>

<scope>
- AWS: Access Key ID/Secret Access Key pairs, session tokens, assumed role credentials
- GCP: Service account JSON key files, OAuth tokens, application default credentials
- Azure: Client ID/Secret pairs, managed identity tokens, SAS tokens, connection strings
- Kubernetes: ServiceAccount tokens, kubeconfig files, cluster certificates
- Generic: API keys, database connection strings, SSH private keys, TLS certificates with keys
- Locations: Git repositories, container images, CI/CD logs, environment variables, config files, backups, client-side code
</scope>

<methodology>
1. Search source code repositories for credential patterns using regex and entropy analysis.
2. Inspect container images for embedded secrets in environment variables, config files, and layers.
3. Review CI/CD pipeline logs and artifacts for leaked credentials.
4. Analyze deployed application code and client-side bundles for hardcoded secrets.
5. Check cloud metadata and environment variables for exposed credentials.
6. Validate discovered credentials by testing their functionality with minimal-impact operations.
7. Document the exposure location, credential scope, and potential impact.
</methodology>

<discovery_techniques>
<repository_scanning>
- Use tools: trufflehog, gitleaks, git-secrets, detect-secrets
- Manual regex: `AKIA[0-9A-Z]{16}` (AWS Access Key ID)
- GCP service account: `"type": "service_account"` with `"private_key":`
- Azure: `DefaultEndpointsProtocol=https;AccountName=`
- Search commit history: `git log -p --all -S 'AKIA'`
- Check .git directory exposure: `curl https://target/.git/config`
</repository_scanning>

<container_images>
- Pull and inspect: `docker pull IMAGE && docker history IMAGE`
- Extract layers: `docker save IMAGE | tar -xf -`
- Search for secrets: `grep -r "AKIA\|password\|secret\|api_key" extracted_layers/`
- Check environment: `docker inspect IMAGE --format='{{.Config.Env}}'`
- Dockerfile inspection: Look for ARG/ENV with secrets, COPY of credential files
</container_images>

<cicd_logs>
- Check GitHub Actions: `.github/workflows/*.yml` and workflow run logs
- GitLab CI: `.gitlab-ci.yml` and job logs
- Jenkins: Build console output, credentials binding
- CircleCI, TravisCI, Azure Pipelines: Check build logs for echoed secrets
- Look for: echo $SECRET, printenv, env dump, failed authentication with credentials shown
</cicd_logs>

<application_code>
- Frontend bundles: Search JS files for API keys, tokens
- Backend configs: application.yml, settings.py, .env files
- Mobile apps: Decompile APK/IPA, search for hardcoded credentials
- Infrastructure as code: Terraform state files, CloudFormation outputs
- Common patterns: `apiKey`, `api_key`, `secret`, `password`, `token`, `credential`
</application_code>

<cloud_metadata>
- AWS IMDS: `curl http://169.254.169.254/latest/meta-data/iam/security-credentials/`
- GCP: `curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token`
- Azure: `curl -H "Metadata: true" "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"`
- ECS task credentials: `curl $AWS_CONTAINER_CREDENTIALS_RELATIVE_URI`
</cloud_metadata>

<credential_patterns>
<aws>
- Access Key ID: `AKIA[0-9A-Z]{16}` or `ASIA[0-9A-Z]{16}` (temporary)
- Secret Access Key: 40-character base64 string
- Session Token: Long base64 string (temporary credentials)
- Account ID: 12-digit number
</aws>

<gcp>
- Service Account Key: JSON with "type": "service_account", "private_key": "-----BEGIN"
- OAuth Token: `ya29.` prefix
- API Key: `AIza[0-9A-Za-z_-]{35}`
</gcp>

<azure>
- Client ID: UUID format `[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}`
- Client Secret: Long string, often base64
- Connection String: `DefaultEndpointsProtocol=https;AccountName=...;AccountKey=...`
- SAS Token: `?sv=...&sig=...`
</azure>

<kubernetes>
- ServiceAccount Token: JWT starting with `eyJ`
- Kubeconfig: `apiVersion: v1` with `clusters:`, `users:`, `contexts:`
- Certificate/Key: `-----BEGIN CERTIFICATE-----`, `-----BEGIN RSA PRIVATE KEY-----`
</kubernetes>
</credential_patterns>
</discovery_techniques>

<validation_techniques>
<aws_validation>
- Identify caller: `aws sts get-caller-identity`
- List permissions (if allowed): `aws iam list-attached-user-policies --user-name $(aws sts get-caller-identity --query 'Arn' --output text | cut -d'/' -f2)`
- Minimal-impact test: `aws s3 ls` (read-only)
- Check for time-limited tokens: Session tokens expire, check `Expiration` field
</aws_validation>

<gcp_validation>
- Authenticate: `gcloud auth activate-service-account --key-file=creds.json`
- Verify: `gcloud auth list`
- Test access: `gcloud projects list`
- Check scopes: Service accounts have limited scopes; verify what APIs are accessible
</gcp_validation>

<azure_validation>
- Get token: `az login --service-principal -u CLIENT_ID -p SECRET --tenant TENANT`
- Verify: `az account show`
- Test access: `az group list` or `az storage account list`
</azure_validation>

<k8s_validation>
- Use token: `kubectl --token=TOKEN --server=SERVER get pods`
- Check permissions: `kubectl auth can-i --list`
- Verify cluster: `kubectl cluster-info`
</k8s_validation>
</validation_techniques>

<validation>
1. Confirm the credential is valid and active (not expired, revoked, or fake).
2. Demonstrate successful authentication using the discovered credential.
3. Document the scope and permissions granted by the credential.
4. Show the exposure location (file path, URL, commit hash, image layer).
5. Verify the credential provides access to production or sensitive resources.
6. Perform only minimal-impact validation operations (read-only when possible).
</validation>

<false_positives>
- Placeholder/example credentials in documentation
- Revoked or rotated credentials (no longer valid)
- Development/sandbox credentials with no production access
- Encrypted credentials that cannot be decrypted without additional keys
- Credential patterns that are not actual credentials (false pattern matches)
- Honeypot credentials designed for detection
- Test API keys with restricted permissions (rate-limited, read-only test data)
</false_positives>

<llm_reasoning_errors>
COMMON AI MISTAKES THAT CAUSE FALSE POSITIVES - AVOID THESE:

1. PATTERN MATCH WITHOUT VALIDATION:
   WRONG: "Found string matching AKIA[A-Z0-9]{16} pattern, AWS credentials exposed"
   RIGHT: Pattern matches are STARTING POINTS, not proof. You MUST:
          - Attempt to use the credential (aws sts get-caller-identity)
          - Verify it returns valid identity, not "InvalidClientTokenId"
          - Many strings match patterns but are not valid credentials
          Report only VALIDATED, WORKING credentials.

2. EXAMPLE/DOCUMENTATION CREDENTIALS:
   WRONG: "README.md contains AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE, credentials leaked"
   RIGHT: "EXAMPLE" suffix and similar patterns indicate DOCUMENTATION examples.
          Common fake credentials:
          - AKIAIOSFODNN7EXAMPLE (AWS example)
          - wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
          - your-api-key-here, xxx, placeholder, dummy
          Always validate before reporting.

3. EXPIRED/REVOKED CREDENTIALS:
   WRONG: "Git history contains old AWS keys, credential exposure vulnerability"
   RIGHT: Historical credentials may be:
          - Already rotated after discovery
          - Expired (session tokens have TTL)
          - Revoked by the organization
          Test that credentials are CURRENTLY valid before reporting.

4. ENCRYPTED OR PARTIAL CREDENTIALS:
   WRONG: "Found encrypted secret in config, credential exposed"
   RIGHT: Encrypted credentials are NOT exposed unless you can decrypt them.
          - Vault-encrypted values
          - SOPS-encrypted files
          - KMS-encrypted secrets
          - Partial credentials (key ID without secret)
          Encryption protects the credential; report only if decryption is possible.

5. DEVELOPMENT/SANDBOX SCOPE:
   WRONG: "API key found in test file, production credentials exposed"
   RIGHT: Many credentials are intentionally limited:
          - Sandbox/development environment keys
          - Test accounts with no real data access
          - Rate-limited or read-only API keys
          Verify the credential has meaningful access before claiming exposure.

6. CREDENTIAL IN PRIVATE CONTEXT:
   WRONG: "Docker image in private ECR contains credentials, exposure confirmed"
   RIGHT: Context matters:
          - Private repositories require authentication to access
          - Private images are not "exposed" to the public
          - Internal config files are not "exposed" if the file itself is protected
          Report credentials in PUBLIC locations or locations accessible to attackers.
</llm_reasoning_errors>

<expanded_false_positives>
FALSE POSITIVE SCENARIOS - DO NOT REPORT:

1. DOCUMENTATION AND EXAMPLES:
   - AWS example key: AKIAIOSFODNN7EXAMPLE
   - Placeholder text: "your-api-key-here", "INSERT_KEY", "xxx"
   - Tutorial/sample code with fake credentials
   - Test fixtures with non-production credentials

2. REVOKED/EXPIRED CREDENTIALS:
   - Credentials in git history that have been rotated
   - Temporary session tokens past expiration
   - API keys that return "invalid" or "revoked" errors
   - Credentials on revocation lists

3. ENCRYPTED/PROTECTED SECRETS:
   - Vault-encrypted values (vault:v1:...)
   - SOPS-encrypted YAML/JSON
   - KMS-encrypted environment variables
   - Sealed Secrets in Kubernetes

4. LIMITED-SCOPE CREDENTIALS:
   - Read-only API keys for public data
   - Sandbox/development environment credentials
   - Rate-limited keys with no sensitive access
   - Demo/trial account credentials

5. PRIVATE LOCATIONS:
   - Private repository credentials (repo itself requires auth)
   - Internal-only container registries
   - Credentials behind VPN/authentication
   - Local development machine files

6. HONEYPOTS AND CANARIES:
   - Deliberately planted fake credentials for detection
   - Canary tokens designed to alert on use
   - Decoy files with tracking credentials

7. INFRASTRUCTURE THAT'S NOT EXPLOITABLE:
   - Credentials for services that don't exist
   - Keys for deleted accounts/projects
   - Connection strings for decommissioned databases
</expanded_false_positives>

<impact>
- Full cloud account takeover via privileged credentials
- Data exfiltration from storage, databases, and secrets managers
- Resource manipulation (compute, network, DNS) for further attacks
- Persistent backdoor access via credential creation
- Lateral movement to connected services and accounts
- Compliance violations and regulatory penalties
- Cryptocurrency mining at victim's expense
- Ransomware deployment via administrative access
</impact>

<pro_tips>
1. Always validate credentials before reporting - false positives damage credibility.
2. Check git history, not just current code: `git log -p --all -S 'AKIA'`.
3. Container image layers can contain deleted secrets - extract all layers.
4. CI/CD logs often expose secrets via debugging output or failed commands.
5. Mobile apps frequently contain hardcoded API keys - decompile and search.
6. Terraform state files contain secrets in plaintext - check for exposed state.
7. Client-side JavaScript bundles often contain API keys meant to be secret.
8. Use minimal-impact validation (read-only operations) to avoid triggering alerts.
9. Document credential scope - a read-only key is less critical than admin.
10. Check for credential rotation patterns - recently rotated keys may indicate prior breach.
</pro_tips>

<remember>Credential exposure requires proof that the credential is valid, active, and provides meaningful access. Pattern matching is just the first step - always validate credentials and verify their scope before reporting. Expired, revoked, or example credentials are not vulnerabilities.</remember>
</cloud_credentials_exposure_guide>
