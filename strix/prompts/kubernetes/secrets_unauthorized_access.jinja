<k8s_secrets_unauthorized_access_guide>
<title>KUBERNETES SECRETS UNAUTHORIZED ACCESS</title>

<critical>Kubernetes secrets store sensitive credentials including cloud provider keys, database passwords, TLS certificates, and service account tokens. Unauthorized access to secrets enables credential theft, lateral movement to cloud resources, and persistent cluster access. Secrets are base64 encoded but NOT encrypted by default, making access equivalent to plaintext credential theft.</critical>

<scope>
- Cloud credentials: AWS access keys, GCP service account keys, Azure service principal secrets stored in secrets
- Service account tokens: Kubernetes API tokens for service accounts with elevated permissions
- TLS certificates and keys: Private keys enabling impersonation or decryption
- Database credentials: Connection strings and passwords for external databases
- Application secrets: API keys, OAuth tokens, encryption keys
- Imagepull secrets: Container registry credentials
- Etcd access: Direct access to unencrypted secrets in etcd data store
</scope>

<methodology>
1. Enumerate accessible secrets across namespaces using RBAC permissions.
2. Check for overly broad secret access in roles and rolebindings.
3. Identify secrets containing high-value credentials (cloud, database, admin tokens).
4. Test secret access from pod contexts (mounted tokens).
5. Validate credential viability by testing authentication.
6. Document the access path and credential scope.
</methodology>

<discovery_techniques>
<secret_enumeration>
- List all secrets (if permitted): `kubectl get secrets --all-namespaces`
- Namespace-specific: `kubectl get secrets -n NAMESPACE`
- Describe secret: `kubectl describe secret SECRET_NAME -n NAMESPACE`
- Get secret data: `kubectl get secret SECRET_NAME -o yaml`
- Decode secret: `kubectl get secret SECRET_NAME -o jsonpath='{.data.KEY}' | base64 -d`
</secret_enumeration>

<high_value_targets>
- Cloud credentials:
  - AWS: `kubectl get secrets --all-namespaces -o json | grep -i 'aws\|access.key\|secret.key'`
  - GCP: `kubectl get secrets --all-namespaces -o json | grep -i 'google\|gcp\|service.account'`
  - Azure: `kubectl get secrets --all-namespaces -o json | grep -i 'azure\|client.secret\|tenant'`
- Database credentials:
  - `kubectl get secrets --all-namespaces -o json | grep -i 'database\|mysql\|postgres\|mongo\|redis'`
- TLS secrets: `kubectl get secrets --all-namespaces -o json | jq '.items[] | select(.type=="kubernetes.io/tls") | .metadata.name'`
- Service account tokens: `kubectl get secrets --all-namespaces -o json | jq '.items[] | select(.type=="kubernetes.io/service-account-token") | .metadata.name'`
</high_value_targets>

<pod_context_access>
- Check mounted secrets: `ls -la /var/run/secrets/kubernetes.io/serviceaccount/`
- Read token: `cat /var/run/secrets/kubernetes.io/serviceaccount/token`
- Use token: `curl -H "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" https://kubernetes.default.svc/api/v1/secrets`
- Environment variables: `env | grep -i secret\|password\|key\|token`
- Volume mounts: `mount | grep secret`
</pod_context_access>

<etcd_access>
If you have access to etcd:
- Direct read: `etcdctl get /registry/secrets --prefix --keys-only`
- Specific secret: `etcdctl get /registry/secrets/NAMESPACE/SECRET_NAME`
- Note: Secrets are stored in plaintext unless encryption at rest is configured
- Check encryption config: `ps aux | grep kube-apiserver | grep encryption-provider-config`
</etcd_access>

<rbac_for_secrets>
- Check permissions: `kubectl auth can-i get secrets --all-namespaces`
- List role rules: `kubectl get clusterroles -o json | jq '.items[] | select(.rules[].resources[]? == "secrets") | {name: .metadata.name, rules: .rules}'`
- Find bindings: `kubectl get clusterrolebindings -o json | jq '.items[] | select(.roleRef.name == "ROLE_WITH_SECRETS") | .subjects'`
</rbac_for_secrets>
</discovery_techniques>

<secret_types>
<kubernetes_types>
- Opaque: Generic secrets (most common)
- kubernetes.io/service-account-token: Auto-generated SA tokens
- kubernetes.io/dockerconfigjson: Container registry credentials
- kubernetes.io/basic-auth: Username/password pairs
- kubernetes.io/ssh-auth: SSH private keys
- kubernetes.io/tls: TLS certificate and key pairs
- bootstrap.kubernetes.io/token: Bootstrap tokens for cluster joining
</kubernetes_types>

<common_naming_patterns>
- Cloud: *-aws-*, *-gcp-*, *-azure-*, cloud-credentials
- Database: *-db-*, *-mysql-*, *-postgres-*, *-mongo-*, db-credentials
- TLS: *-tls, *-cert, *-ssl
- Registry: regcred, docker-*, pull-secret
- Admin: admin-*, *-admin, *-root
</common_naming_patterns>
</secret_types>

<exploitation>
<cloud_credential_abuse>
1. Extract cloud credentials from secret
2. Configure CLI: `export AWS_ACCESS_KEY_ID=... AWS_SECRET_ACCESS_KEY=...`
3. Verify: `aws sts get-caller-identity`
4. Enumerate permissions and pivot to cloud resources
5. Check for admin/power user access enabling full cloud takeover
</cloud_credential_abuse>

<service_account_token_abuse>
1. Extract SA token from secret or pod mount
2. Test token permissions: `kubectl --token=TOKEN auth can-i --list`
3. If privileged, use for cluster operations
4. Check if token has cloud provider roles (EKS IRSA, GKE Workload Identity)
</service_account_token_abuse>

<tls_key_abuse>
1. Extract TLS private key from secret
2. Use for MITM attacks on services using that certificate
3. Impersonate services in mTLS environments
4. Decrypt captured TLS traffic if ephemeral key exchange not used
</tls_key_abuse>

<registry_credential_abuse>
1. Extract imagePullSecret
2. Decode docker config: `base64 -d | jq`
3. Login to registry: `docker login REGISTRY -u USER -p PASSWORD`
4. Pull private images containing more secrets
5. Push malicious images for supply chain attacks
</registry_credential_abuse>
</exploitation>

<validation>
1. Demonstrate successful secret retrieval with kubectl or API output.
2. Decode and verify the secret contains meaningful credentials.
3. Test credential validity by authenticating to the target system.
4. Document the scope and permissions of retrieved credentials.
5. Show the access path (RBAC permissions or pod context).
6. Verify credentials are for production/sensitive systems, not test data.
</validation>

<false_positives>
- Secrets containing only non-sensitive configuration
- Expired or rotated credentials
- Test/development credentials with no production access
- Secrets you're authorized to access in your role
- Encrypted secrets that cannot be decrypted without additional keys
- Placeholder or example credentials
</false_positives>

<llm_reasoning_errors>
COMMON AI MISTAKES THAT CAUSE FALSE POSITIVES - AVOID THESE:

1. SECRET ACCESS VS SENSITIVE CONTENT:
   WRONG: "Can read secrets in namespace X, credential theft confirmed"
   RIGHT: Not all secrets contain sensitive credentials:
          - ConfigMap-like data stored in secrets
          - Non-sensitive application configuration
          - Certificates without corresponding private keys
          Verify the secret CONTENT is actually sensitive.

2. EXPIRED OR ROTATED CREDENTIALS:
   WRONG: "Found AWS credentials in secret, cloud access possible"
   RIGHT: Credentials may be:
          - Rotated since deployment (old secrets remain)
          - Expired temporary credentials
          - Deactivated or deleted in cloud provider
          VALIDATE credentials work before reporting.

3. TEST/DEVELOPMENT SCOPE:
   WRONG: "Database password found, data breach possible"
   RIGHT: Verify the credential scope:
          - Development database with test data only
          - Read-only credentials
          - Credentials for non-existent or empty database
          Report the actual access level, not assumed worst case.

4. AUTHORIZED ACCESS:
   WRONG: "Service account can read secrets in its namespace, vulnerability"
   RIGHT: Many service accounts legitimately need secrets:
          - Application pods reading their own config secrets
          - Operators managing secrets in their namespace
          - Controllers needing credentials for their function
          Unauthorized access means accessing secrets outside intended scope.

5. BASE64 CONFUSION:
   WRONG: "Secret data is encoded, sensitive information exposed"
   RIGHT: Base64 is encoding, NOT encryption:
          - All Kubernetes secrets are base64 encoded by design
          - This is NOT a vulnerability
          - The vulnerability is unauthorized ACCESS, not the encoding
          Focus on who can access, not the encoding format.

6. MOUNTED VS ACCESSIBLE:
   WRONG: "Secret is mounted in pod, sensitive data exposed"
   RIGHT: Mounted secrets are accessible from WITHIN that pod:
          - This is how secrets are designed to work
          - The pod is supposed to access its secrets
          - Vulnerability is when OTHER pods/users access them
          Pod accessing its own secrets is intended behavior.
</llm_reasoning_errors>

<expanded_false_positives>
FALSE POSITIVE SCENARIOS - DO NOT REPORT:

1. NON-SENSITIVE SECRET CONTENT:
   - Configuration data stored as secrets (labels, endpoints)
   - Feature flags and application settings
   - Public certificates (without private keys)
   - Hash values that cannot be reversed

2. AUTHORIZED SECRET ACCESS:
   - Application reading its own secrets via volume mounts
   - Operators managing secrets they are designed to manage
   - CI/CD systems with deployment permissions
   - Backup systems with secret read access for their function

3. INVALID/EXPIRED CREDENTIALS:
   - Rotated credentials from previous deployments
   - Expired OAuth tokens
   - Deactivated cloud credentials
   - Deleted accounts/services

4. DEVELOPMENT/TEST SCOPE:
   - Sandbox database credentials
   - Test API keys with limited access
   - Development cluster secrets
   - Training environment credentials

5. ENCRYPTION AT REST:
   - Secrets encrypted in etcd (EncryptionConfiguration)
   - Secrets managed by external vaults (HashiCorp, AWS, GCP)
   - Sealed Secrets that require controller to decrypt
   - SOPS-encrypted secret manifests

6. INTENTIONAL EXPOSURE:
   - Demo credentials for testing
   - Example values in documentation secrets
   - Honeypot secrets for detection
</expanded_false_positives>

<impact>
- Cloud account compromise via stolen cloud credentials
- Database access and data exfiltration
- Lateral movement to external services using stolen API keys
- Persistent cluster access via service account tokens
- Supply chain attacks via container registry access
- TLS impersonation and traffic decryption
- Privilege escalation if secrets contain admin credentials
</impact>

<pro_tips>
1. Always validate credentials work before reporting - many are rotated or expired.
2. Check if encryption at rest is configured: `ps aux | grep encryption-provider-config`.
3. Service account tokens in secrets are deprecated (v1.24+); check for TokenRequest API.
4. ImagePullSecrets often have write access to registries - test for push capability.
5. Cloud credentials in secrets may have IAM roles attached (IRSA, Workload Identity).
6. Secrets in kube-system namespace are high-value targets.
7. Check for external secrets operators (ESO) that sync from vaults.
8. Mounted secrets in /var/run/secrets are common - check all running pods.
9. etcd access provides all secrets regardless of RBAC.
10. Secret names often reveal their purpose - prioritize cloud/admin/database patterns.
</pro_tips>

<remember>Secret access vulnerability requires demonstrating access to secrets you should NOT have access to, containing credentials that are valid and provide meaningful access. Base64 encoding is NOT the vulnerability - unauthorized access is. Always validate credentials and document actual impact.</remember>
</k8s_secrets_unauthorized_access_guide>
