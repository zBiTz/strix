<broken_function_level_authorization_guide>
<title>BROKEN FUNCTION LEVEL AUTHORIZATION (BFLA)</title>

<critical>BFLA is action-level authorization failure: callers invoke functions (endpoints, mutations, admin tools) they are not entitled to. It appears when enforcement differs across transports, gateways, roles, or when services trust client hints. Bind subject × action at the service that performs the action.</critical>

<scope>
- Vertical authz: privileged/admin/staff-only actions reachable by basic users
- Feature gates: toggles enforced at edge/UI, not at core services
- Transport drift: REST vs GraphQL vs gRPC vs WebSocket with inconsistent checks
- Gateway trust: backends trust X-User-Id/X-Role injected by proxies/edges
- Background workers/jobs performing actions without re-checking authz
</scope>

<methodology>
1. Build an Actor × Action matrix with at least: unauth, basic, premium, staff/admin. Enumerate actions (create/update/delete, approve/cancel, impersonate, export, invite, role-change, credit/refund).
2. Obtain tokens/sessions for each role. Exercise every action across all transports and encodings (JSON, form, multipart), including method overrides.
3. Vary headers and contextual selectors (org/tenant/project) and test behavior behind gateway vs direct-to-service.
4. Include background flows: job creation/finalization, webhooks, queues. Confirm re-validation of authz in consumers.
</methodology>

<discovery_techniques>
<surface_enumeration>
- Admin/staff consoles and APIs, support tools, internal-only endpoints exposed via gateway
- Hidden buttons and disabled UI paths (feature-flagged) mapped to still-live endpoints
- GraphQL schemas: mutations and admin-only fields/types; gRPC service descriptors (reflection)
- Mobile clients often reveal extra endpoints/roles in app bundles or network logs
</surface_enumeration>

<signals>
- 401/403 on UI but 200 via direct API call; differing status codes across transports
- Actions succeed via background jobs when direct call is denied
- Changing only headers (role/org) alters access without token change
</signals>

<high_value_actions>
- Role/permission changes, impersonation/sudo, invite/accept into orgs
- Approve/void/refund/credit issuance, price/plan overrides
- Export/report generation, data deletion, account suspension/reactivation
- Feature flag toggles, quota/grant adjustments, license/seat changes
- Security settings: 2FA reset, email/phone verification overrides
</high_value_actions>

<exploitation_techniques>
<verb_drift_and_aliases>
- Alternate methods: GET performing state change; POST vs PUT vs PATCH differences; X-HTTP-Method-Override/_method
- Alternate endpoints performing the same action with weaker checks (legacy vs v2, mobile vs web)
</verb_drift_and_aliases>

<edge_vs_core_mismatch>
- Edge blocks an action but core service RPC accepts it directly; call internal service via exposed API route or SSRF
- Gateway-injected identity headers override token claims; supply conflicting headers to test precedence
</edge_vs_core_mismatch>

<feature_flag_bypass>
- Client-checked feature gates; call backend endpoints directly
- Admin-only mutations exposed but hidden in UI; invoke via GraphQL or gRPC tools
</feature_flag_bypass>

<batch_job_paths>
- Create export/import jobs where creation is allowed but finalize/approve lacks authz; finalize others' jobs
- Replay webhooks/background tasks endpoints that perform privileged actions without verifying caller
</batch_job_paths>

<content_type_paths>
- JSON vs form vs multipart handlers using different middleware: send the action via the most permissive parser
</content_type_paths>
</exploitation_techniques>

<advanced_techniques>
<graphql>
- Resolver-level checks per mutation/field; do not assume top-level auth covers nested mutations or admin fields
- Abuse aliases/batching to sneak privileged fields; persisted queries sometimes bypass auth transforms
- Example:
{% raw %}
mutation Promote($id:ID!){
  a: updateUser(id:$id, role: ADMIN){ id role }
}
{% endraw %}
</graphql>

<grpc>
- Method-level auth via interceptors must enforce audience/roles; probe direct gRPC with tokens of lower role
- Reflection lists services/methods; call admin methods that the gateway hid
</grpc>

<websocket>
- Handshake-only auth: ensure per-message authorization on privileged events (e.g., admin:impersonate)
- Try emitting privileged actions after joining standard channels
</websocket>

<multi_tenant>
- Actions requiring tenant admin enforced only by header/subdomain; attempt cross-tenant admin actions by switching selectors with same token
</multi_tenant>

<microservices>
- Internal RPCs trust upstream checks; reach them through exposed endpoints or SSRF; verify each service re-enforces authz
</microservices>

<bypass_techniques>
<header_trust>
- Supply X-User-Id/X-Role/X-Organization headers; remove or contradict token claims; observe which source wins
</header_trust>

<route_shadowing>
- Legacy/alternate routes (e.g., /admin/v1 vs /v2/admin) that skip new middleware chains
</route_shadowing>

<idempotency_and_retries>
- Retry or replay finalize/approve endpoints that apply state without checking actor on each call
</idempotency_and_retries>

<cache_key_confusion>
- Cached authorization decisions at edge leading to cross-user reuse; test with Vary and session swaps
</cache_key_confusion>
</bypass_techniques>

<validation>
1. Show a lower-privileged principal successfully invokes a restricted action (same inputs) while the proper role succeeds and another lower role fails.
2. Provide evidence across at least two transports or encodings demonstrating inconsistent enforcement.
3. Demonstrate that removing/altering client-side gates (buttons/flags) does not affect backend success.
4. Include durable state change proof: before/after snapshots, audit logs, and authoritative sources.
</validation>

<false_positives>
- Read-only endpoints mislabeled as admin but publicly documented
- Feature toggles intentionally open to all roles for preview/beta with clear policy
- Simulated environments where admin endpoints are stubbed with no side effects
</false_positives>

<llm_reasoning_errors>
COMMON AI MISTAKES THAT CAUSE FALSE POSITIVES - AVOID THESE:

1. ENDPOINT EXISTS != ACCESSIBLE:
   WRONG: "Found /admin/users endpoint in JavaScript, BFLA vulnerability"
   RIGHT: Finding an endpoint doesn't mean you can access it.
          Test: (1) call the endpoint with a low-privilege token,
          (2) confirm you get 200 with actual data/action, not 401/403.
          Endpoint discovery is not the same as broken authorization.

2. ADMIN DOING ADMIN THINGS:
   WRONG: "Admin user can delete any user, broken authorization"
   RIGHT: Admins are SUPPOSED to have elevated privileges.
          BFLA requires: (1) action restricted to certain roles,
          (2) LOWER privilege role successfully performs it.
          Admin doing admin things is expected behavior.

3. UI HIDDEN != SERVER PROTECTED:
   WRONG: "Button is hidden in UI but endpoint works, BFLA confirmed"
   RIGHT: Hidden UI elements don't guarantee server protection.
          But you must verify with a DIFFERENT, LOWER privilege account.
          If you're already authorized, the hidden button is just UX.
          Test: Does a regular user token get the same result?

4. SAME USER DIFFERENT PATHS:
   WRONG: "User can access /api/v2/admin/settings via direct call"
   RIGHT: If the user is an admin, this is expected.
          If there's no role difference between UI and API, no BFLA.
          BFLA requires ROLE ESCALATION: user → admin function access.

5. FEATURE FLAG CONFUSION:
   WRONG: "Beta feature is accessible to all users, broken authorization"
   RIGHT: Beta features may intentionally be open to all users.
          Check: Is this feature SUPPOSED to be admin-only?
          Documented beta/preview features are not BFLA.

6. TRANSPORT DIFFERENCE WITHOUT AUTHZ DIFFERENCE:
   WRONG: "GraphQL allows same operations as REST, inconsistent"
   RIGHT: Multiple transports (REST, GraphQL, gRPC) offering same operations
          is not a vulnerability if authorization is consistent.
          Test: Does a low-privilege user get MORE access via GraphQL?
</llm_reasoning_errors>

<expanded_false_positives>
FALSE POSITIVE SCENARIOS - DO NOT REPORT:

1. PROPER AUTHORIZATION ENFORCEMENT:
   - Endpoint returns 401/403 for unprivileged users
   - Admin endpoints require admin token/session
   - Function access matches documented role requirements
   - Multi-tenant isolation prevents cross-org access

2. INTENDED ROLE CAPABILITIES:
   - Admin performing admin functions
   - Super-user with documented elevated privileges
   - Support staff with intentional override capabilities
   - Service accounts with specific function access

3. DIFFERENT ACCESS != BROKEN ACCESS:
   - Multiple valid paths to same function (REST + GraphQL)
   - API versioning with consistent authorization
   - Mobile and web with same authorization model
   - Internal and external APIs with proper scoping

4. FEATURE AVAILABILITY:
   - Beta features open to all users (documented policy)
   - Preview features for early adopters
   - Gradual rollout features
   - A/B test variations

5. TESTING/DEVELOPMENT:
   - Staging environments with relaxed auth (not production)
   - Test accounts with elevated permissions
   - Mock endpoints without real authorization
   - Demo modes with full feature access
</expanded_false_positives>

<impact>
- Privilege escalation to admin/staff actions
- Monetary/state impact: refunds/credits/approvals without authorization
- Tenant-wide configuration changes, impersonation, or data deletion
- Compliance and audit violations due to bypassed approval workflows
</impact>

<pro_tips>
1. Start from the role matrix; test every action with basic vs admin tokens across REST/GraphQL/gRPC.
2. Diff middleware stacks between routes; weak chains often exist on legacy or alternate encodings.
3. Inspect gateways for identity header injection; never trust client-provided identity.
4. Treat jobs/webhooks as first-class: finalize/approve must re-check the actor.
5. Prefer minimal PoCs: one request that flips a privileged field or invokes an admin method with a basic token.
</pro_tips>

<remember>Authorization must bind the actor to the specific action at the service boundary on every request and message. UI gates, gateways, or prior steps do not substitute for function-level checks.</remember>
</broken_function_level_authorization_guide>
