<path_traversal_lfi_rfi_guide>
<title>PATH TRAVERSAL, LFI, AND RFI</title>

<critical>Improper file path handling and dynamic inclusion enable sensitive file disclosure, config/source leakage, SSRF pivots, and code execution. Treat all user-influenced paths, names, and schemes as untrusted; normalize and bind them to an allowlist or eliminate user control entirely.</critical>

<scope>
- Path traversal: read files outside intended roots via ../, encoding, normalization gaps
- Local File Inclusion (LFI): include server-side files into interpreters/templates
- Remote File Inclusion (RFI): include remote resources (HTTP/FTP/wrappers) for code execution
- Archive extraction traversal (Zip Slip): write outside target directory upon unzip/untar
- Server/proxy normalization mismatches (nginx alias/root, upstream decoders)
- OS-specific paths: Windows separators, device names, UNC, NT paths, alternate data streams
</scope>

<methodology>
1. Inventory all file operations: downloads, previews, templates, logs, exports/imports, report engines, uploads, archive extractors.
2. Identify input joins: path joins (base + user), include/require/template loads, resource fetchers, archive extract destinations.
3. Probe normalization and resolution: separators, encodings, double-decodes, case, trailing dots/slashes; compare web server vs application behavior.
4. Escalate from disclosure (read) to influence (write/extract/include), then to execution (wrapper/engine chains).
</methodology>

<discovery_techniques>
<surface_map>
- HTTP params: file, path, template, include, page, view, download, export, report, log, dir, theme, lang
- Upload and conversion pipelines: image/PDF renderers, thumbnailers, office converters
- Archive extract endpoints and background jobs; imports with ZIP/TAR/GZ/7z
- Server-side template rendering (PHP/Smarty/Twig/Blade), email templates, CMS themes/plugins
- Reverse proxies and static file servers (nginx, CDN) in front of app handlers
</surface_map>

<capability_probes>
- Path traversal baseline: ../../etc/hosts and C:\\Windows\\win.ini
- Encodings: %2e%2e%2f, %252e%252e%252f, ..%2f, ..%5c, mixed UTF-8 (%c0%2e), Unicode dots and slashes
- Normalization tests: ....//, ..\\, ././, trailing dot/double dot segments; repeated decoding
- Absolute path acceptance: /etc/passwd, C:\\Windows\\System32\\drivers\\etc\\hosts
- Server mismatch: /static/..;/../etc/passwd ("..;"), encoded slashes (%2F), double-decoding via upstream
</capability_probes>
</discovery_techniques>

<detection_channels>
<direct>
- Response body discloses file content (text, binary, base64); error pages echo real paths
</direct>

<error_based>
- Exception messages expose canonicalized paths or include() warnings with real filesystem locations
</error_based>

<oast>
- RFI/LFI with wrappers that trigger outbound fetches (HTTP/DNS) to confirm inclusion/execution
</oast>

<side_effects>
- Archive extraction writes files unexpectedly outside target; verify with directory listings or follow-up reads
</side_effects>
</detection_channels>

<path_traversal>
<bypasses_and_variants>
- Encodings: single/double URL-encoding, mixed case, overlong UTF-8, UTF-16, path normalization oddities
- Mixed separators: / and \\ on Windows; // and \\\\ collapse differences across frameworks
- Dot tricks: ....// (double dot folding), trailing dots (Windows), trailing slashes, appended valid extension
- Absolute path injection: bypass joins by supplying a rooted path
- Alias/root mismatch (nginx): alias without trailing slash with nested location allows ../ to escape; try /static/../etc/passwd and ";" variants (..;)
- Upstream vs backend decoding: proxies/CDNs decoding %2f differently; test double-decoding and encoded dots
</bypasses_and_variants>

<high_value_targets>
- /etc/passwd, /etc/hosts, application .env/config.yaml, SSH/keys, cloud creds, service configs/logs
- Windows: C:\\Windows\\win.ini, IIS/web.config, programdata configs, application logs
- Source code templates and server-side includes; secrets in env dumps
</high_value_targets>
</path_traversal>

<lfi>
<wrappers_and_techniques>
- PHP wrappers: php://filter/convert.base64-encode/resource=index.php (read source), zip://archive.zip#file.txt, data://text/plain;base64, expect:// (if enabled)
- Log/session poisoning: inject PHP/templating payloads into access/error logs or session files then include them (paths vary by stack)
- Upload temp names: include temporary upload files before relocation; race with scanners
- /proc/self/environ and framework-specific caches for readable secrets
- Null-byte (legacy): %00 truncation in older stacks; path length truncation tricks
</wrappers_and_techniques>

<template_engines>
- PHP include/require; Smarty/Twig/Blade with dynamic template names
- Java/JSP/FreeMarker/Velocity; Node.js ejs/handlebars/pug engines
- Seek dynamic template resolution from user input (theme/lang/template)
</template_engines>
</lfi>

<rfi>
<conditions>
- Remote includes (allow_url_include/allow_url_fopen in PHP), custom fetchers that eval/execute retrieved content, SSRF-to-exec bridges
- Protocol handlers: http, https, ftp; language-specific stream handlers
</conditions>

<exploitation>
- Host a minimal payload that proves code execution; prefer OAST beacons or deterministic output over heavy shells
- Chain with upload or log poisoning when remote includes are disabled to reach local payloads
</exploitation>
</rfi>

<archive_extraction>
<zip_slip>
- Files within archives containing ../ or absolute paths escape target extract directory
- Test multiple formats: zip/tar/tgz/7z; verify symlink handling and path canonicalization prior to write
- Impact: overwrite config/templates or drop webshells into served directories
</zip_slip>
</archive_extraction>

<validation>
1. Show a minimal traversal read proving out-of-root access (e.g., /etc/hosts) with a same-endpoint in-root control.
2. For LFI, demonstrate inclusion of a benign local file or harmless wrapper output (php://filter base64 of index.php); avoid active code when not permitted.
3. For RFI, prove remote fetch by OAST or controlled output; avoid destructive payloads.
4. For Zip Slip, create an archive with ../ entries and show write outside target (e.g., marker file read back).
5. Provide before/after file paths, exact requests, and content hashes/lengths for reproducibility.
</validation>

<false_positives>
- In-app virtual paths that do not map to filesystem; content comes from safe stores (DB/object storage)
- Canonicalized paths constrained to an allowlist/root after normalization
- Wrappers disabled and includes using constant templates only
- Archive extractors that sanitize paths and enforce destination directories
</false_positives>

<llm_reasoning_errors>
COMMON AI MISTAKES THAT CAUSE FALSE POSITIVES - AVOID THESE:

1. ERROR MESSAGE CONFUSION:
   WRONG: "The server returned 'file not found' error mentioning a path, proving path traversal"
   RIGHT: Error messages indicating file not found mean the traversal FAILED.
          Path traversal requires: (1) traversal sequence accepted, (2) file CONTENT returned.
          "No such file" errors indicate the path was rejected or doesn't exist.

2. PARAMETER NAME ASSUMPTION:
   WRONG: "Parameter named 'file' or 'path' exists, path traversal likely"
   RIGHT: Parameter names don't indicate vulnerability. You must PROVE:
          - The parameter influences filesystem operations
          - Traversal sequences bypass path restrictions
          - Out-of-root file content is actually returned
          Many "file" params refer to database IDs or virtual paths.

3. ENCODING WITHOUT EXPLOITATION:
   WRONG: "I sent ..%2f..%2f and got a different response, confirming bypass"
   RIGHT: Different responses can be: (1) WAF blocking, (2) 400 bad request,
          (3) application error. Vulnerability requires ACTUAL file content.
          Prove: Show /etc/passwd content or other known file, not just response differences.

4. RELATIVE PATH ACCEPTANCE:
   WRONG: "Server accepts 'documents/report.pdf' without error, path traversal possible"
   RIGHT: Accepting relative paths within the intended directory is NORMAL.
          Path traversal requires ESCAPING the intended directory.
          Test: ../../../etc/passwd - did you get passwd content or an error?

5. LFI WRAPPER CONFUSION:
   WRONG: "php://filter returned base64 content, LFI confirmed"
   RIGHT: php://filter returning encoded content IS the proof of LFI.
          But verify: (1) you controlled the path, (2) content is the target file.
          Some apps intentionally use wrappers for their own files.

6. ZIP SLIP WITHOUT EXTRACTION:
   WRONG: "I uploaded a ZIP with ../ entries, Zip Slip vulnerability"
   RIGHT: Uploading is not the vulnerability. You must prove:
          - ZIP was actually extracted server-side
          - Files were written outside target directory
          - You can access/read the escaped file
          Many apps store ZIPs without extracting them.
</llm_reasoning_errors>

<expanded_false_positives>
FALSE POSITIVE SCENARIOS - DO NOT REPORT:

1. VIRTUAL PATH SYSTEMS:
   - "file=report-123" mapping to database records, not filesystem
   - Content served from object storage (S3, GCS) with path-like keys
   - Template systems using IDs that look like paths
   - CMS with "path" parameters referring to URL slugs

2. PROPER PATH NORMALIZATION:
   - Application resolves to canonical path then validates against allowlist
   - Framework's built-in path handling (e.g., Flask send_from_directory)
   - Web server properly configured (nginx with correct alias syntax)
   - Path operations fail cleanly on traversal attempts

3. RESTRICTED WRAPPERS:
   - php://filter disabled or limited to specific directories
   - allow_url_include/allow_url_fopen disabled (RFI impossible)
   - Stream wrappers registered only for safe operations
   - Include paths hardcoded or from constants only

4. SAFE ARCHIVE HANDLING:
   - Extraction library validates all paths before writing
   - Symlinks not followed during extraction
   - Destination directory enforced after canonicalization
   - Archive contents validated against allowlist

5. INFORMATIONAL ONLY:
   - Path disclosed in error message but not exploitable
   - Server returns 403/404 on traversal (working protection)
   - Different error codes for ../  vs normal paths (detection, not bypass)
   - Response size differences without actual file content
</expanded_false_positives>

<impact>
- Sensitive configuration/source disclosure â†’ credential and key compromise
- Code execution via inclusion of attacker-controlled content or overwritten templates
- Persistence via dropped files in served directories; lateral movement via revealed secrets
- Supply-chain impact when report/template engines execute attacker-influenced files
</impact>

<pro_tips>
1. Compare content-length/ETag when content is masked; read small canonical files (hosts) to avoid noise.
2. Test proxy/CDN and app separately; decoding/normalization order differs, especially for %2f and %2e encodings.
3. For LFI, prefer php://filter base64 probes over destructive payloads; enumerate readable logs and sessions.
4. Validate extraction code with synthetic archives; include symlinks and deep ../ chains.
5. Use minimal PoCs and hard evidence (hashes, paths). Avoid noisy DoS against filesystems.
</pro_tips>

<remember>Eliminate user-controlled paths where possible. Otherwise, resolve to canonical paths and enforce allowlists, forbid remote schemes, and lock down interpreters and extractors. Normalize consistently at the boundary closest to IO.</remember>
</path_traversal_lfi_rfi_guide>
