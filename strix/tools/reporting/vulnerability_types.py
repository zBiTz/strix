"""Vulnerability type registry with claim validation requirements.

This module defines specifications for each vulnerability type, including
the control tests required to validate that a finding is genuine and not
a false positive. The verification agent uses these specs to design
independent validation tests.
"""

from dataclasses import dataclass


@dataclass
class ControlTestRequirement:
    """A required control test to validate a vulnerability claim.

    The verification agent must design and execute this test independently
    to confirm the vulnerability is genuine.
    """

    name: str
    """Unique identifier for this control test (e.g., 'direct_path_access')."""

    description: str
    """What this test proves about the vulnerability."""

    test_template: str
    """How to design and execute this test."""

    success_criteria: str
    """What result indicates the vulnerability is genuine."""

    failure_indicates: str
    """What a failed test result means (usually false positive)."""


@dataclass
class VulnerabilityTypeSpec:
    """Complete specification for a vulnerability type.

    Defines validation requirements that must be checked independently
    by the verification agent to confirm a finding is genuine.
    """

    type_id: str
    """Unique identifier matching prompt module name (e.g., 'path_traversal_lfi_rfi')."""

    display_name: str
    """Human-readable name for reports."""

    control_test_requirements: list[ControlTestRequirement]
    """Control tests the verification agent must perform independently."""

    validity_criteria: list[str]
    """Conditions that must all be true for a valid finding."""

    false_positive_patterns: list[str]
    """Common patterns that indicate false positives."""

    semantic_claim: str
    """The core security claim this vulnerability type makes."""


# =============================================================================
# VULNERABILITY TYPE SPECIFICATIONS
# =============================================================================

PATH_TRAVERSAL_LFI_RFI = VulnerabilityTypeSpec(
    type_id="path_traversal_lfi_rfi",
    display_name="Path Traversal / LFI / RFI",
    semantic_claim="Attacker can access files outside the intended directory by using traversal sequences",
    control_test_requirements=[
        ControlTestRequirement(
            name="direct_path_access",
            description="Verify the target resource is actually access-controlled",
            test_template="""
            1. Identify the resolved path from the traversal (e.g., ../../etc/passwd -> /etc/passwd)
            2. Test DIRECT access to that resolved path without traversal
            3. Compare: Can you access the resource directly vs via traversal?
            """,
            success_criteria="Direct access is DENIED (403/404) but traversal access SUCCEEDS (200 with content)",
            failure_indicates="If direct access also returns the same content, the resource is publicly accessible - NOT a vulnerability",
        ),
        ControlTestRequirement(
            name="file_content_verification",
            description="Verify actual file content was retrieved, not just path manipulation",
            test_template="""
            1. Check if response contains recognizable file content
            2. For /etc/passwd: look for root:x:0:0 format
            3. For config files: look for configuration syntax
            4. Compare to error pages - file content should differ structurally
            """,
            success_criteria="Response contains structured file content matching expected format",
            failure_indicates="If response is 404, error page, or traversal sequences echoed back - NOT exploited",
        ),
        ControlTestRequirement(
            name="baseline_comparison",
            description="Establish baseline of in-directory access vs out-of-directory",
            test_template="""
            1. Access a known file INSIDE the intended directory (baseline)
            2. Access a known file OUTSIDE via traversal (exploit)
            3. Access a nonexistent file (error baseline)
            4. All three should have distinct responses
            """,
            success_criteria="Three distinct response types: authorized file, unauthorized file via traversal, error",
            failure_indicates="If traversal response matches error response, traversal is being blocked",
        ),
    ],
    validity_criteria=[
        "File content from OUTSIDE intended directory is retrieved",
        "Content is actual file data, not error messages or reflections",
        "Direct access to the same resource is denied or unavailable",
        "Traversal sequences are processed by the server, not blocked",
    ],
    false_positive_patterns=[
        "404 or 'file not found' errors on traversal attempts",
        "Error messages mentioning paths without actual file content",
        "Traversal sequences echoed/reflected in response",
        "Virtual path systems mapping to database IDs",
        "Both direct and traversal access return same content (public resource)",
    ],
)

IDOR = VulnerabilityTypeSpec(
    type_id="idor",
    display_name="Insecure Direct Object Reference (IDOR)",
    semantic_claim="Attacker can access or modify objects belonging to other users by manipulating object identifiers",
    control_test_requirements=[
        ControlTestRequirement(
            name="authorization_boundary_test",
            description="Verify that authorization exists and is being bypassed",
            test_template="""
            1. Identify the resource being accessed (e.g., /api/users/123)
            2. Access the SAME resource as an UNAUTHORIZED user (different account or unauthenticated)
            3. Compare responses: authorized vs unauthorized access to same resource
            """,
            success_criteria="Unauthorized access returns 403/401, but ID manipulation with authorized token succeeds",
            failure_indicates="If unauthorized access also succeeds, resource may be intentionally public",
        ),
        ControlTestRequirement(
            name="cross_account_verification",
            description="Confirm you accessed another user's data, not your own",
            test_template="""
            1. Use Account A to access resource belonging to Account B
            2. Verify the returned data belongs to Account B (different user ID, email, etc.)
            3. Confirm Account A does not legitimately have access to Account B's data
            """,
            success_criteria="Data returned clearly belongs to a different user/account than the requester",
            failure_indicates="If data matches requester's own data, this is self-access not IDOR",
        ),
        ControlTestRequirement(
            name="public_data_exclusion",
            description="Confirm the accessed data should be private",
            test_template="""
            1. Check if the data type is intentionally public (user profiles, published posts)
            2. Review application context - is this a directory, social network, or private system?
            3. Test if unauthenticated users can access similar data
            """,
            success_criteria="Data type is clearly private (PII, financial, health, internal) not public profiles",
            failure_indicates="If data is intentionally public by design, this is not IDOR",
        ),
    ],
    validity_criteria=[
        "Accessed data belongs to a DIFFERENT user than the authenticated requester",
        "The data type is meant to be private/protected, not public",
        "Proper authorization would deny this access",
        "The access occurs via direct object reference manipulation",
    ],
    false_positive_patterns=[
        "Accessing your own data via different ID formats",
        "Public user profiles or published content",
        "Admin/staff accessing data they're authorized to see",
        "Enumeration of existence without content access",
        "Role-appropriate access (manager seeing team data)",
    ],
)

SQL_INJECTION = VulnerabilityTypeSpec(
    type_id="sql_injection",
    display_name="SQL Injection",
    semantic_claim="Attacker can inject SQL commands that are executed by the database",
    control_test_requirements=[
        ControlTestRequirement(
            name="predicate_control_test",
            description="Prove you can control query logic, not just cause errors",
            test_template="""
            1. Send payload with TRUE predicate: ' AND 1=1--
            2. Send payload with FALSE predicate: ' AND 1=2--
            3. Compare responses - they MUST differ consistently
            4. The difference must be in DATA returned, not just error messages
            """,
            success_criteria="TRUE and FALSE predicates produce consistently different data responses",
            failure_indicates="If both return errors or same data, query is not being influenced",
        ),
        ControlTestRequirement(
            name="data_extraction_test",
            description="Prove data can be extracted, not just errors triggered",
            test_template="""
            1. Attempt to extract known metadata: database version, current user, database name
            2. Use appropriate technique: UNION, error-based, blind boolean, or time-based
            3. Verify extracted data is valid (not error text or garbage)
            """,
            success_criteria="Successfully extracted verifiable database metadata or table data",
            failure_indicates="If only errors without data extraction, impact is not proven",
        ),
        ControlTestRequirement(
            name="timing_validation",
            description="For time-based: Prove delay correlates to SLEEP, not network",
            test_template="""
            1. Baseline: 5+ requests WITHOUT sleep - record response times
            2. Exploit: 5+ requests WITH SLEEP(5) - record response times
            3. Compare distributions - exploit requests must be ~5s slower consistently
            4. Verify: SLEEP(0) vs SLEEP(5) must show clear time difference
            """,
            success_criteria="SLEEP payload adds consistent, predictable delay matching sleep duration",
            failure_indicates="If timing is inconsistent or not correlated to sleep value, may be network variance",
        ),
    ],
    validity_criteria=[
        "Query behavior is demonstrably controlled by injected input",
        "Data can be extracted OR query logic can be altered",
        "Differences are in data/behavior, not just error messages",
        "Injection is server-side SQL, not client-side or display",
    ],
    false_positive_patterns=[
        "Generic database errors (connection, constraint violations)",
        "Response size differences from timestamps/tokens",
        "Inconsistent timing not correlated to sleep duration",
        "Parameterized queries with proper binding",
        "WAF blocks without successful bypass",
    ],
)

XSS = VulnerabilityTypeSpec(
    type_id="xss",
    display_name="Cross-Site Scripting (XSS)",
    semantic_claim="Attacker can inject scripts that execute in victims' browsers",
    control_test_requirements=[
        ControlTestRequirement(
            name="execution_verification",
            description="Verify script EXECUTES, not just reflects",
            test_template="""
            1. Inject payload with observable effect: <script>alert(1)</script>
            2. Load the page in an ACTUAL BROWSER
            3. Check if alert fires OR use non-alert verification (DOM changes, fetch to OAST)
            4. View source is NOT sufficient - must verify browser execution
            """,
            success_criteria="Script executes in browser: alert fires, DOM changes, or OAST callback received",
            failure_indicates="If payload appears in source but doesn't execute, it's encoded or in non-executing context",
        ),
        ControlTestRequirement(
            name="encoding_check",
            description="Verify output is not properly encoded",
            test_template="""
            1. Check how special characters appear in response
            2. Look for: < vs &lt;, > vs &gt;, " vs &quot;
            3. If characters are HTML-encoded, script won't execute
            """,
            success_criteria="Special characters appear unencoded in exploitable context",
            failure_indicates="HTML entities (&lt; &gt; &quot;) indicate proper encoding - not vulnerable",
        ),
        ControlTestRequirement(
            name="context_validation",
            description="Verify injection is in executable context",
            test_template="""
            1. Identify WHERE payload appears: HTML body, attribute, JavaScript, CSS, URL
            2. Check if context allows execution:
               - <title>/<textarea>: scripts don't execute
               - Attribute with quotes: need to break out
               - JavaScript string: need to break out of string
            3. Verify breakout is possible and payload executes
            """,
            success_criteria="Payload is in context where browsers will execute the script",
            failure_indicates="Payload in non-executing context (title, textarea, properly quoted attr)",
        ),
    ],
    validity_criteria=[
        "Script actually EXECUTES in browser, not just reflects",
        "Output is not HTML-encoded",
        "Injection is in an executable context",
        "Payload persists (stored) or is triggered via crafted URL (reflected)",
    ],
    false_positive_patterns=[
        "Payload appears in source but doesn't execute",
        "HTML entities encoding special characters",
        "Injection in non-executable contexts (title, textarea)",
        "CSP blocking script execution",
        "Reflection without execution",
    ],
)

SSRF = VulnerabilityTypeSpec(
    type_id="ssrf",
    display_name="Server-Side Request Forgery (SSRF)",
    semantic_claim="Attacker can make the server send requests to internal resources or arbitrary destinations",
    control_test_requirements=[
        ControlTestRequirement(
            name="server_side_verification",
            description="Verify request is SERVER-initiated, not client-side",
            test_template="""
            1. Set up OAST listener for HTTP callbacks
            2. Submit URL pointing to your OAST endpoint
            3. Check OAST logs for request SOURCE IP
            4. If source IP is target server (not your browser) = server-side
            """,
            success_criteria="OAST callback received from TARGET SERVER IP, not client browser",
            failure_indicates="If request comes from your browser IP, this is client-side fetch not SSRF",
        ),
        ControlTestRequirement(
            name="internal_access_test",
            description="Verify access to internal/restricted resources",
            test_template="""
            1. Test access to internal addresses: 127.0.0.1, localhost, 169.254.169.254
            2. Test access to internal services: port 6379 (Redis), 9200 (Elasticsearch)
            3. Compare responses to public URLs vs internal URLs
            4. Look for: metadata responses, internal service banners, port status differences
            """,
            success_criteria="Can access internal resources that are not publicly accessible",
            failure_indicates="If only external URLs work and all internal blocked, impact is limited",
        ),
        ControlTestRequirement(
            name="intended_functionality_check",
            description="Verify this isn't intentional external fetch behavior",
            test_template="""
            1. Understand the feature: URL preview? Webhook? Import?
            2. Check if fetching external URLs is the intended purpose
            3. SSRF requires accessing UNINTENDED targets (internal, metadata)
            4. External-to-external fetch may be by design
            """,
            success_criteria="Can access internal/unintended resources beyond feature's intended scope",
            failure_indicates="If feature is designed to fetch external URLs and that's all it does, not SSRF",
        ),
    ],
    validity_criteria=[
        "Request is initiated by SERVER, not client",
        "Can access internal resources (localhost, metadata, internal services)",
        "Access goes beyond intended functionality",
        "Actual data/response from internal resource, not just timeout differences",
    ],
    false_positive_patterns=[
        "Client-side fetches (visible in browser network tab)",
        "Intended external fetch features (URL preview, webhooks)",
        "All internal access blocked (connection refused uniformly)",
        "OAST callback but no internal access possible",
        "Metadata endpoints blocked by cloud provider protections",
    ],
)

RCE = VulnerabilityTypeSpec(
    type_id="rce",
    display_name="Remote Code Execution (RCE)",
    semantic_claim="Attacker can execute arbitrary code or commands on the server",
    control_test_requirements=[
        ControlTestRequirement(
            name="command_execution_proof",
            description="Verify command actually executes on server",
            test_template="""
            1. Use benign verification commands: whoami, hostname, id
            2. Capture command output in response OR via out-of-band
            3. Verify output matches expected server context (not local/client)
            4. Cross-reference with OAST callbacks for blind execution
            """,
            success_criteria="Command output proves server-side execution (server hostname, server user)",
            failure_indicates="If output matches local machine or is not returned, execution not proven",
        ),
        ControlTestRequirement(
            name="output_source_verification",
            description="Confirm output is from server, not client-side evaluation",
            test_template="""
            1. Compare command output to known server characteristics
            2. Check for server-specific paths, users, hostnames
            3. Use unique identifiers in commands (random strings in files)
            4. Verify via OAST if in-band output is unreliable
            """,
            success_criteria="Output contains server-specific identifiers not available client-side",
            failure_indicates="Generic output or client-matching data suggests no server execution",
        ),
    ],
    validity_criteria=[
        "Arbitrary commands execute on the SERVER",
        "Command output or side effects prove execution",
        "Attacker controls the command content",
        "Execution is not sandboxed/harmless",
    ],
    false_positive_patterns=[
        "Client-side JavaScript eval",
        "Template injection without server execution",
        "Command reflection without execution",
        "Sandboxed execution with no escape",
    ],
)

CSRF = VulnerabilityTypeSpec(
    type_id="csrf",
    display_name="Cross-Site Request Forgery (CSRF)",
    semantic_claim="Attacker can trick authenticated users into performing unintended actions",
    control_test_requirements=[
        ControlTestRequirement(
            name="state_change_verification",
            description="Verify action causes meaningful state change",
            test_template="""
            1. Identify a state-changing action (update, delete, transfer)
            2. Craft cross-origin request (form, XHR if CORS allows)
            3. Verify the action COMPLETES and state CHANGES
            4. Check if action requires only cookies (no CSRF token)
            """,
            success_criteria="State-changing action completes when triggered cross-origin",
            failure_indicates="If action requires CSRF token, custom header, or re-auth, CSRF is mitigated",
        ),
        ControlTestRequirement(
            name="token_bypass_verification",
            description="Verify CSRF protections can be bypassed",
            test_template="""
            1. Check for CSRF token in forms/headers
            2. Test: Remove token, empty token, token from different session
            3. Check for SameSite cookie attribute
            4. Test if request works without protections
            """,
            success_criteria="Request succeeds without valid CSRF token or with bypassed protections",
            failure_indicates="If valid CSRF token required and verified, protection works",
        ),
    ],
    validity_criteria=[
        "Action is state-changing (not just read)",
        "Action can be triggered cross-origin",
        "No effective CSRF token or protection",
        "Authentication is cookie-based (automatically sent)",
    ],
    false_positive_patterns=[
        "Read-only actions (no state change)",
        "CSRF token required and validated",
        "SameSite=Strict cookies preventing cross-origin",
        "Custom headers required (prevents simple form POST)",
        "Re-authentication required for action",
    ],
)

AUTHENTICATION_JWT = VulnerabilityTypeSpec(
    type_id="authentication_jwt",
    display_name="Authentication / JWT Vulnerabilities",
    semantic_claim="Attacker can bypass authentication or forge/manipulate authentication tokens",
    control_test_requirements=[
        ControlTestRequirement(
            name="bypass_verification",
            description="Verify authentication can be bypassed or token forged",
            test_template="""
            1. Identify authentication mechanism (JWT, session, API key)
            2. Test bypass: alg=none, weak key, expired token acceptance
            3. Verify bypassed auth grants access to protected resources
            4. Compare authenticated vs bypassed access to same resource
            """,
            success_criteria="Access to protected resources achieved without valid credentials",
            failure_indicates="If bypass attempts are rejected, authentication is working",
        ),
        ControlTestRequirement(
            name="token_manipulation_test",
            description="For JWT: verify token can be manipulated and accepted",
            test_template="""
            1. Decode JWT and modify claims (user ID, role, expiry)
            2. Test: algorithm confusion (RS256->HS256), none algorithm
            3. Re-sign with known/guessed key or submit unsigned
            4. Verify modified token is accepted
            """,
            success_criteria="Modified token accepted and grants elevated/different access",
            failure_indicates="If modified tokens are rejected with signature errors, JWT is properly validated",
        ),
    ],
    validity_criteria=[
        "Authentication bypass or token forgery is possible",
        "Bypassed auth grants access to protected resources",
        "Token manipulation is not detected/rejected",
        "Issue is server-side validation failure, not client-side",
    ],
    false_positive_patterns=[
        "Token modifications rejected with signature error",
        "Expired tokens correctly rejected",
        "Algorithm confusion not possible (strict validation)",
        "None algorithm rejected",
    ],
)

XXE = VulnerabilityTypeSpec(
    type_id="xxe",
    display_name="XML External Entity (XXE) Injection",
    semantic_claim="Attacker can inject malicious XML entities to read files, SSRF, or execute code",
    control_test_requirements=[
        ControlTestRequirement(
            name="entity_expansion_test",
            description="Verify external entities are processed",
            test_template="""
            1. Submit XML with external entity: <!ENTITY xxe SYSTEM "file:///etc/passwd">
            2. Reference entity in XML body: &xxe;
            3. Check if file content appears in response
            4. Use OAST for blind XXE: <!ENTITY xxe SYSTEM "http://oast-server/xxe">
            """,
            success_criteria="Entity expands to file content OR OAST callback received",
            failure_indicates="If entity not expanded or errors returned, XXE is disabled",
        ),
        ControlTestRequirement(
            name="parser_configuration_test",
            description="Verify XML parser allows external entities",
            test_template="""
            1. Test with known-working XXE payloads for common parsers
            2. Try different entity types: SYSTEM, PUBLIC, parameter entities
            3. Test with and without DTD validation
            4. Check error messages for parser configuration hints
            """,
            success_criteria="At least one entity type is processed and exploitable",
            failure_indicates="Parser configured to disallow external entities",
        ),
    ],
    validity_criteria=[
        "XML parser processes external entity definitions",
        "Entity expansion returns file content or triggers OAST",
        "Exploitation is server-side, not client-side",
        "DTD processing or external entity resolution is enabled",
    ],
    false_positive_patterns=[
        "Parser disables external entities by default",
        "DTD processing disabled",
        "Error messages but no entity expansion",
        "Client-side XML parsing only",
    ],
)

BUSINESS_LOGIC = VulnerabilityTypeSpec(
    type_id="business_logic",
    display_name="Business Logic Vulnerabilities",
    semantic_claim="Attacker can abuse application workflow or logic to achieve unintended outcomes",
    control_test_requirements=[
        ControlTestRequirement(
            name="intended_vs_actual_behavior",
            description="Verify behavior deviates from intended business rules",
            test_template="""
            1. Document the expected business flow/rules
            2. Identify deviation: what should NOT be possible?
            3. Demonstrate the unintended outcome achieved
            4. Confirm this is not intended behavior (check docs, context)
            """,
            success_criteria="Achieved outcome that violates documented business rules",
            failure_indicates="If behavior is within intended parameters, not a vulnerability",
        ),
        ControlTestRequirement(
            name="security_impact_verification",
            description="Verify logic flaw has security impact",
            test_template="""
            1. Quantify impact: financial, access, data exposure
            2. Verify impact is meaningful (not trivial or theoretical)
            3. Document concrete harm to organization or users
            """,
            success_criteria="Demonstrated concrete security impact from logic bypass",
            failure_indicates="If no meaningful impact, may be usability issue not security",
        ),
    ],
    validity_criteria=[
        "Behavior deviates from intended business rules",
        "Deviation has security impact",
        "Can be reliably reproduced",
        "Not just edge case or race condition",
    ],
    false_positive_patterns=[
        "Behavior is actually intended",
        "Edge case with no security impact",
        "Requires insider knowledge not available to attacker",
        "Compensating controls prevent exploitation",
    ],
)

RACE_CONDITIONS = VulnerabilityTypeSpec(
    type_id="race_conditions",
    display_name="Race Conditions",
    semantic_claim="Attacker can exploit timing windows to bypass checks or duplicate actions",
    control_test_requirements=[
        ControlTestRequirement(
            name="timing_exploitation_test",
            description="Verify race condition is exploitable, not theoretical",
            test_template="""
            1. Identify the TOCTOU (time-of-check-to-time-of-use) window
            2. Send parallel requests (10+) within the timing window
            3. Check for race success indicators: duplicate transactions, balance changes
            4. Repeat multiple times to confirm reproducibility
            """,
            success_criteria="Race condition exploited: duplicate action, balance manipulation, or check bypass",
            failure_indicates="If atomic operations or locking prevents exploitation, not exploitable",
        ),
        ControlTestRequirement(
            name="impact_verification",
            description="Verify race condition has meaningful impact",
            test_template="""
            1. Document what the race achieves (double spend, auth bypass, etc.)
            2. Quantify impact: financial value, privilege gained
            3. Verify impact persists and is not auto-corrected
            """,
            success_criteria="Race condition leads to persistent unauthorized state change",
            failure_indicates="If effects are transient or auto-corrected, impact is minimal",
        ),
    ],
    validity_criteria=[
        "TOCTOU window exists and is exploitable",
        "Exploitation leads to meaningful security impact",
        "Race is reproducible (not just theoretical)",
        "No compensating controls prevent impact",
    ],
    false_positive_patterns=[
        "Database transactions prevent race",
        "Atomic operations in use",
        "Effects auto-corrected by reconciliation",
        "Theoretical race without practical exploitation",
    ],
)

INSECURE_FILE_UPLOADS = VulnerabilityTypeSpec(
    type_id="insecure_file_uploads",
    display_name="Insecure File Uploads",
    semantic_claim="Attacker can upload malicious files that lead to code execution or other attacks",
    control_test_requirements=[
        ControlTestRequirement(
            name="execution_verification",
            description="Verify uploaded file can be executed",
            test_template="""
            1. Upload file with server-side executable extension (.php, .jsp, .aspx)
            2. Locate the uploaded file URL
            3. Request the file and check if code executes
            4. Verify execution via output or OAST callback
            """,
            success_criteria="Uploaded server-side code executes when accessed",
            failure_indicates="If file served as static content or blocked, no execution",
        ),
        ControlTestRequirement(
            name="content_type_bypass",
            description="Verify content type restrictions are bypassable",
            test_template="""
            1. Test extension manipulation: .php.jpg, .php%00.jpg, .pHp
            2. Test content type mismatch: image/jpeg header with PHP content
            3. Test double extensions and null bytes
            4. Verify bypass results in executable file
            """,
            success_criteria="Bypass technique results in executable file on server",
            failure_indicates="If all bypass techniques fail, upload is properly restricted",
        ),
    ],
    validity_criteria=[
        "Malicious file can be uploaded",
        "File is accessible via URL",
        "Server executes file content",
        "Extension/content restrictions are bypassable",
    ],
    false_positive_patterns=[
        "Files served as static/binary content only",
        "Files stored with safe extensions",
        "Execution prevented by server configuration",
        "Files stored outside web root",
    ],
)

MASS_ASSIGNMENT = VulnerabilityTypeSpec(
    type_id="mass_assignment",
    display_name="Mass Assignment",
    semantic_claim="Attacker can set restricted object properties by including them in request",
    control_test_requirements=[
        ControlTestRequirement(
            name="property_injection_test",
            description="Verify restricted properties can be set",
            test_template="""
            1. Identify protected properties (role, isAdmin, verified, balance)
            2. Add protected property to request body
            3. Check if property was set/modified on server
            4. Verify change persists and has effect
            """,
            success_criteria="Restricted property successfully set via request injection",
            failure_indicates="If property ignored or rejected, mass assignment is prevented",
        ),
    ],
    validity_criteria=[
        "Restricted property can be set via request",
        "Change persists on server",
        "Property affects security-relevant functionality",
        "No explicit allowlist blocking the property",
    ],
    false_positive_patterns=[
        "Property ignored by server",
        "Allowlist prevents restricted properties",
        "Property set but no security impact",
        "Read-only fields not affected",
    ],
)

INFORMATION_DISCLOSURE = VulnerabilityTypeSpec(
    type_id="information_disclosure",
    display_name="Information Disclosure",
    semantic_claim="Attacker can access sensitive information not intended for public access",
    control_test_requirements=[
        ControlTestRequirement(
            name="sensitivity_verification",
            description="Verify disclosed information is sensitive",
            test_template="""
            1. Classify the information: credentials, PII, internal paths, source code
            2. Assess impact: can info be used for further attacks?
            3. Verify info should be protected (not public by design)
            """,
            success_criteria="Information is sensitive and can enable further attacks",
            failure_indicates="If information is public or not useful, low/no impact",
        ),
        ControlTestRequirement(
            name="access_control_test",
            description="Verify information should be restricted",
            test_template="""
            1. Check if information is intentionally public
            2. Compare authenticated vs unauthenticated access
            3. Review application purpose - is disclosure expected?
            """,
            success_criteria="Information is restricted but accessible to unauthorized parties",
            failure_indicates="If information is public by design, not a vulnerability",
        ),
    ],
    validity_criteria=[
        "Disclosed information is sensitive",
        "Information is not intentionally public",
        "Disclosure enables further attacks or causes harm",
        "Access control should prevent disclosure",
    ],
    false_positive_patterns=[
        "Publicly intended information",
        "Version numbers or non-sensitive headers",
        "Debug info that doesn't enable attacks",
        "Error messages without sensitive data",
    ],
)

OPEN_REDIRECT = VulnerabilityTypeSpec(
    type_id="open_redirect",
    display_name="Open Redirect",
    semantic_claim="Attacker can redirect users to malicious external sites via application",
    control_test_requirements=[
        ControlTestRequirement(
            name="external_redirect_test",
            description="Verify redirect to external domain is possible",
            test_template="""
            1. Identify redirect parameter (url=, next=, redirect=)
            2. Set parameter to external domain (https://evil.com)
            3. Verify browser is redirected to external domain
            4. Test bypass variations: //evil.com, ///evil.com, evil.com%00.trusted.com
            """,
            success_criteria="Redirect to fully external domain controlled by attacker",
            failure_indicates="If redirect blocked or only same-domain, not exploitable",
        ),
        ControlTestRequirement(
            name="phishing_viability",
            description="Verify redirect can be used for phishing",
            test_template="""
            1. Craft URL that looks legitimate (on target domain)
            2. Verify redirect lands on external site
            3. Assess whether users would trust the initial URL
            """,
            success_criteria="Legitimate-looking URL redirects to attacker-controlled site",
            failure_indicates="If URL looks suspicious or redirect is obviously unsafe, limited impact",
        ),
    ],
    validity_criteria=[
        "Redirect to external domain is possible",
        "Attacker controls destination URL",
        "Initial URL appears legitimate",
        "No warnings or interstitials",
    ],
    false_positive_patterns=[
        "Redirect only to same-origin paths",
        "Allowlisted domains only",
        "Redirect requires authentication/confirmation",
        "Interstitial page warns about redirect",
    ],
)

SUBDOMAIN_TAKEOVER = VulnerabilityTypeSpec(
    type_id="subdomain_takeover",
    display_name="Subdomain Takeover",
    semantic_claim="Attacker can control a subdomain by claiming dangling DNS records",
    control_test_requirements=[
        ControlTestRequirement(
            name="dns_claim_verification",
            description="Verify subdomain can be claimed",
            test_template="""
            1. Identify dangling CNAME/A record pointing to unclaimed resource
            2. Check if target service allows claiming the resource
            3. Claim the resource (e.g., S3 bucket, Heroku app, Azure blob)
            4. Verify your content is served on the subdomain
            """,
            success_criteria="Your content is served on the target subdomain",
            failure_indicates="If resource cannot be claimed or DNS doesn't resolve to your content",
        ),
        ControlTestRequirement(
            name="control_demonstration",
            description="Verify full control of subdomain content",
            test_template="""
            1. Serve custom content on the subdomain
            2. Verify content is accessible via the subdomain
            3. Demonstrate control (custom HTML, cookie setting)
            """,
            success_criteria="Full control of content served on subdomain demonstrated",
            failure_indicates="If partial or no control, impact may be limited",
        ),
    ],
    validity_criteria=[
        "DNS record points to claimable resource",
        "Resource can be claimed by attacker",
        "Attacker-controlled content served on subdomain",
        "Subdomain is part of main domain trust boundary",
    ],
    false_positive_patterns=[
        "Resource already claimed by organization",
        "DNS properly configured",
        "Service doesn't allow claiming",
        "Subdomain outside trust boundary",
    ],
)

BROKEN_FUNCTION_LEVEL_AUTHORIZATION = VulnerabilityTypeSpec(
    type_id="broken_function_level_authorization",
    display_name="Broken Function Level Authorization",
    semantic_claim="Attacker can access administrative or restricted functions without proper authorization",
    control_test_requirements=[
        ControlTestRequirement(
            name="privilege_boundary_test",
            description="Verify function access crosses privilege boundary",
            test_template="""
            1. Identify admin/privileged function endpoints
            2. Access with low-privilege or no credentials
            3. Verify function executes despite lack of authorization
            4. Confirm function should require higher privileges
            """,
            success_criteria="Privileged function accessible to unauthorized users",
            failure_indicates="If function properly blocked, authorization is working",
        ),
    ],
    validity_criteria=[
        "Function requires specific privilege level",
        "Lower-privileged user can access function",
        "Function actually executes (not just endpoint discovered)",
        "Access has meaningful security impact",
    ],
    false_positive_patterns=[
        "Function properly requires authentication",
        "Function discovery without execution",
        "Intended access for user's role",
        "No meaningful function beyond the check",
    ],
)

HTTP_REQUEST_SMUGGLING = VulnerabilityTypeSpec(
    type_id="http_request_smuggling",
    display_name="HTTP Request Smuggling",
    semantic_claim="Attacker can desynchronize HTTP request boundaries between frontend and backend",
    control_test_requirements=[
        ControlTestRequirement(
            name="desync_verification",
            description="Verify request desynchronization occurs",
            test_template="""
            1. Craft CL.TE or TE.CL smuggling payload
            2. Send smuggled request followed by normal request
            3. Check if second request is affected by smuggled content
            4. Verify through response mismatch or request poisoning
            """,
            success_criteria="Second request affected by smuggled content from first request",
            failure_indicates="If requests are properly synchronized, smuggling failed",
        ),
    ],
    validity_criteria=[
        "Frontend and backend interpret boundaries differently",
        "Smuggled request affects subsequent requests",
        "Can poison cache or hijack requests",
        "Multiple requests needed to verify",
    ],
    false_positive_patterns=[
        "Single-server setup (no FE/BE mismatch)",
        "Proper normalization in place",
        "Requests properly synchronized",
        "Ambiguous parsing rejected",
    ],
)

CACHE_POISONING = VulnerabilityTypeSpec(
    type_id="cache_poisoning",
    display_name="Cache Poisoning",
    semantic_claim="Attacker can poison cached responses to serve malicious content to other users",
    control_test_requirements=[
        ControlTestRequirement(
            name="poison_propagation_test",
            description="Verify poisoned response is served to other users",
            test_template="""
            1. Identify cache key (URL, headers used for keying)
            2. Send request with malicious payload that gets cached
            3. Send clean request from different client
            4. Verify clean client receives poisoned response
            """,
            success_criteria="Clean client receives poisoned content from cache",
            failure_indicates="If each client gets their own response, caching not exploitable",
        ),
    ],
    validity_criteria=[
        "Response is cached and shared",
        "Poisoned response served to other users",
        "Unkeyed input reflects in response",
        "Cache key doesn't include malicious input",
    ],
    false_positive_patterns=[
        "Cache per-user only",
        "No caching in place",
        "Malicious input becomes cache key",
        "Cache properly validates responses",
    ],
)

CRLF_HEADER_INJECTION = VulnerabilityTypeSpec(
    type_id="crlf_header_injection",
    display_name="CRLF / Header Injection",
    semantic_claim="Attacker can inject headers or control response by injecting CRLF sequences",
    control_test_requirements=[
        ControlTestRequirement(
            name="header_injection_test",
            description="Verify custom headers can be injected",
            test_template="""
            1. Inject CRLF sequences: %0d%0a, %0a, actual newlines
            2. Attempt to set custom header after CRLF
            3. Check response for injected header
            4. Verify header is processed (not just reflected)
            """,
            success_criteria="Custom header appears in HTTP response and is processed",
            failure_indicates="If CRLF sequences are filtered or encoded, injection prevented",
        ),
    ],
    validity_criteria=[
        "CRLF sequences are processed, not filtered",
        "Can inject arbitrary headers",
        "Injected headers affect response behavior",
        "Can potentially inject response body (HTTP response splitting)",
    ],
    false_positive_patterns=[
        "CRLF sequences URL-encoded in output",
        "Newlines stripped or rejected",
        "Headers reflected but not processed",
        "Only affects log files (lower impact)",
    ],
)

OAUTH_OIDC_MISCONFIGURATION = VulnerabilityTypeSpec(
    type_id="oauth_oidc_misconfiguration",
    display_name="OAuth/OIDC Misconfiguration",
    semantic_claim="Attacker can exploit OAuth/OIDC misconfigurations to gain unauthorized access",
    control_test_requirements=[
        ControlTestRequirement(
            name="token_theft_or_bypass",
            description="Verify OAuth flow can be exploited",
            test_template="""
            1. Test redirect_uri manipulation (open redirect to attacker domain)
            2. Check for token leakage (state missing, fragment leakage)
            3. Test PKCE bypass (if applicable)
            4. Verify token/code can be stolen or forged
            """,
            success_criteria="Can steal token/code or bypass OAuth flow",
            failure_indicates="If flow properly validates all parameters, not exploitable",
        ),
    ],
    validity_criteria=[
        "OAuth flow has exploitable weakness",
        "Can steal token/code or impersonate users",
        "Redirect URI not properly validated",
        "State parameter missing or predictable",
    ],
    false_positive_patterns=[
        "Strict redirect URI validation",
        "State parameter properly implemented",
        "PKCE required and validated",
        "Token binding in use",
    ],
)

DESERIALIZATION = VulnerabilityTypeSpec(
    type_id="deserialization",
    display_name="Insecure Deserialization",
    semantic_claim="Attacker can achieve code execution or logic bypass through malicious serialized objects",
    control_test_requirements=[
        ControlTestRequirement(
            name="gadget_chain_execution",
            description="Verify deserialization gadget chain executes",
            test_template="""
            1. Identify serialization format (Java, Python pickle, PHP, etc.)
            2. Craft payload with known gadget chain
            3. Submit serialized payload
            4. Verify execution via OAST callback or observable effect
            """,
            success_criteria="Gadget chain executes: OAST callback or command output",
            failure_indicates="If payload rejected or no execution, gadgets may not be available",
        ),
    ],
    validity_criteria=[
        "Untrusted serialized data is deserialized",
        "Exploitable gadget chain exists",
        "Execution or logic bypass achieved",
        "Not just data modification",
    ],
    false_positive_patterns=[
        "Type filtering prevents gadget loading",
        "Look-ahead deserialization in use",
        "No exploitable gadget chain available",
        "Serialized data is signed/encrypted",
    ],
)

NOSQL_LDAP_INJECTION = VulnerabilityTypeSpec(
    type_id="nosql_ldap_injection",
    display_name="NoSQL / LDAP Injection",
    semantic_claim="Attacker can inject queries to NoSQL databases or LDAP directories",
    control_test_requirements=[
        ControlTestRequirement(
            name="query_manipulation_test",
            description="Verify query behavior can be controlled",
            test_template="""
            1. For NoSQL: Test operator injection {$gt:""}, {$where:"1==1"}
            2. For LDAP: Test )(uid=*), *)(|(uid=*
            3. Verify different results from TRUE vs FALSE predicates
            4. Extract data or bypass authentication
            """,
            success_criteria="Query behavior controlled: auth bypass, data extraction, or response differences",
            failure_indicates="If injection filtered or no query change, not exploitable",
        ),
    ],
    validity_criteria=[
        "Query operators/filters can be injected",
        "Query behavior changes with injection",
        "Can bypass auth or extract data",
        "Input reaches query without sanitization",
    ],
    false_positive_patterns=[
        "Operators properly escaped",
        "Parameterized queries used",
        "Input sanitization in place",
        "No observable query change",
    ],
)

SSTI = VulnerabilityTypeSpec(
    type_id="ssti",
    display_name="Server-Side Template Injection (SSTI)",
    semantic_claim="Attacker can inject template code that executes on the server",
    control_test_requirements=[
        ControlTestRequirement(
            name="template_execution_test",
            description="Verify template expressions are evaluated",
            test_template="""
            1. Send basic math expression: {{7*7}}, ${7*7}, #{7*7}
            2. Check if output shows "49" (evaluated) vs literal string
            3. Progress to RCE payloads if expression evaluates
            4. Use template-specific payloads for identified engine
            """,
            success_criteria="Template expression evaluates to result (49), not reflected literally",
            failure_indicates="If literal {{7*7}} returned, not evaluating as template",
        ),
        ControlTestRequirement(
            name="rce_progression_test",
            description="Verify SSTI can achieve code execution",
            test_template="""
            1. Identify template engine from error messages or behavior
            2. Use engine-specific RCE payload
            3. Verify command execution via output or OAST
            """,
            success_criteria="Server-side command execution achieved via template injection",
            failure_indicates="If no RCE gadgets available, impact may be limited",
        ),
    ],
    validity_criteria=[
        "Template expressions are evaluated server-side",
        "Can access dangerous objects/methods",
        "Can achieve RCE or sensitive data access",
        "Not just client-side template evaluation",
    ],
    false_positive_patterns=[
        "Client-side template (Angular, Vue)",
        "Template strings reflected not evaluated",
        "Sandbox prevents dangerous access",
        "Only string interpolation, no object access",
    ],
)

RATE_LIMITING_ABUSE = VulnerabilityTypeSpec(
    type_id="rate_limiting_abuse",
    display_name="Rate Limiting / Brute Force",
    semantic_claim="Attacker can bypass rate limits to perform brute force or resource exhaustion attacks",
    control_test_requirements=[
        ControlTestRequirement(
            name="limit_bypass_test",
            description="Verify rate limit can be bypassed",
            test_template="""
            1. Identify rate-limited endpoint (login, API)
            2. Test bypass: different IPs, headers, user agents, API keys
            3. Check if limit resets or can be circumvented
            4. Verify useful attacks (brute force, scraping) are possible
            """,
            success_criteria="Rate limit bypassed: sustained high request rate achieved",
            failure_indicates="If consistently blocked after limit, rate limiting works",
        ),
    ],
    validity_criteria=[
        "Rate limit exists but can be bypassed",
        "Bypass enables meaningful attack (brute force, scraping)",
        "Attack is sustained, not just occasional extra request",
        "Has security impact beyond annoyance",
    ],
    false_positive_patterns=[
        "Rate limit properly enforced",
        "Bypass requires unrealistic resources",
        "No sensitive operation to brute force",
        "Limit is by design generous",
    ],
)

CORS_MISCONFIGURATION = VulnerabilityTypeSpec(
    type_id="cors_misconfiguration",
    display_name="CORS Misconfiguration",
    semantic_claim="Attacker can exploit CORS policy to access sensitive data cross-origin",
    control_test_requirements=[
        ControlTestRequirement(
            name="origin_reflection_test",
            description="Verify sensitive data accessible with arbitrary origin",
            test_template="""
            1. Request with Origin: https://evil.com header
            2. Check Access-Control-Allow-Origin response
            3. Verify: arbitrary origin reflected, or null/wildcard with credentials
            4. Confirm sensitive data in response
            """,
            success_criteria="Sensitive data accessible with attacker-controlled origin",
            failure_indicates="If CORS properly restricts origins, not exploitable",
        ),
        ControlTestRequirement(
            name="credential_inclusion_test",
            description="Verify cookies/auth included in cross-origin request",
            test_template="""
            1. Check Access-Control-Allow-Credentials: true
            2. Verify cookies/session sent with cross-origin request
            3. Confirm authenticated data returned
            """,
            success_criteria="Authenticated data accessible via cross-origin request",
            failure_indicates="Without credentials, only public data accessible",
        ),
    ],
    validity_criteria=[
        "Origin is reflected or overly permissive",
        "Credentials are allowed cross-origin",
        "Sensitive/authenticated data in response",
        "Data is not publicly accessible anyway",
    ],
    false_positive_patterns=[
        "Strict origin allowlist",
        "Wildcard without credentials",
        "Only public endpoints affected",
        "SameSite cookies prevent abuse",
    ],
)

APPLICATION_DOS = VulnerabilityTypeSpec(
    type_id="application_dos",
    display_name="Application-Level Denial of Service",
    semantic_claim="Attacker can cause service disruption through application-layer attacks",
    control_test_requirements=[
        ControlTestRequirement(
            name="resource_exhaustion_test",
            description="Verify DoS causes measurable service impact",
            test_template="""
            1. Identify resource-intensive operation (regex, file, query)
            2. Craft payload that triggers excessive resource use
            3. Measure impact: response time, error rate, availability
            4. Verify impact affects other users/requests
            """,
            success_criteria="Measurable service degradation affecting other users",
            failure_indicates="If impact isolated or no degradation, DoS not effective",
        ),
    ],
    validity_criteria=[
        "Single/few requests cause disproportionate load",
        "Service degradation is measurable",
        "Impact affects other users",
        "Attack is practical (doesn't require massive resources)",
    ],
    false_positive_patterns=[
        "Timeouts prevent resource exhaustion",
        "Rate limiting blocks attack",
        "Impact only affects attacker's request",
        "Resource use is proportional to input",
    ],
)

CLICKJACKING = VulnerabilityTypeSpec(
    type_id="clickjacking",
    display_name="Clickjacking / UI Redressing",
    semantic_claim="Attacker can trick users into clicking hidden elements via iframe embedding",
    control_test_requirements=[
        ControlTestRequirement(
            name="framing_test",
            description="Verify target page can be framed",
            test_template="""
            1. Check for X-Frame-Options or CSP frame-ancestors header
            2. Attempt to iframe the target page from attacker domain
            3. Verify page renders in iframe without blocking
            4. Test on state-changing actions (not just content)
            """,
            success_criteria="Page with sensitive action loads in cross-origin iframe",
            failure_indicates="If framing blocked by XFO or CSP, clickjacking prevented",
        ),
        ControlTestRequirement(
            name="action_exploitability_test",
            description="Verify useful action can be clickjacked",
            test_template="""
            1. Identify one-click state-changing action
            2. Verify action doesn't require confirmation/CAPTCHA
            3. Demonstrate click can trigger action via iframe
            """,
            success_criteria="Meaningful action triggered via clickjacking",
            failure_indicates="If only informational pages frameable, limited impact",
        ),
    ],
    validity_criteria=[
        "Page can be loaded in iframe",
        "No X-Frame-Options or CSP frame-ancestors blocking",
        "Sensitive one-click action available",
        "Action can be triggered through clickjacking",
    ],
    false_positive_patterns=[
        "X-Frame-Options: DENY present",
        "CSP frame-ancestors restricts origins",
        "No sensitive actions on page",
        "Action requires confirmation dialog",
    ],
)


# =============================================================================
# REGISTRY
# =============================================================================

VULNERABILITY_TYPE_REGISTRY: dict[str, VulnerabilityTypeSpec] = {
    "path_traversal_lfi_rfi": PATH_TRAVERSAL_LFI_RFI,
    "idor": IDOR,
    "sql_injection": SQL_INJECTION,
    "xss": XSS,
    "ssrf": SSRF,
    "rce": RCE,
    "csrf": CSRF,
    "authentication_jwt": AUTHENTICATION_JWT,
    "xxe": XXE,
    "business_logic": BUSINESS_LOGIC,
    "race_conditions": RACE_CONDITIONS,
    "insecure_file_uploads": INSECURE_FILE_UPLOADS,
    "mass_assignment": MASS_ASSIGNMENT,
    "information_disclosure": INFORMATION_DISCLOSURE,
    "open_redirect": OPEN_REDIRECT,
    "subdomain_takeover": SUBDOMAIN_TAKEOVER,
    "broken_function_level_authorization": BROKEN_FUNCTION_LEVEL_AUTHORIZATION,
    "http_request_smuggling": HTTP_REQUEST_SMUGGLING,
    "cache_poisoning": CACHE_POISONING,
    "crlf_header_injection": CRLF_HEADER_INJECTION,
    "oauth_oidc_misconfiguration": OAUTH_OIDC_MISCONFIGURATION,
    "deserialization": DESERIALIZATION,
    "nosql_ldap_injection": NOSQL_LDAP_INJECTION,
    "ssti": SSTI,
    "rate_limiting_abuse": RATE_LIMITING_ABUSE,
    "cors_misconfiguration": CORS_MISCONFIGURATION,
    "application_dos": APPLICATION_DOS,
    "clickjacking": CLICKJACKING,
}


def get_vulnerability_type_spec(type_id: str) -> VulnerabilityTypeSpec | None:
    """Get the specification for a vulnerability type.

    Args:
        type_id: Vulnerability type identifier (e.g., 'path_traversal_lfi_rfi')

    Returns:
        VulnerabilityTypeSpec if found, None otherwise
    """
    return VULNERABILITY_TYPE_REGISTRY.get(type_id)


def get_all_type_ids() -> list[str]:
    """Get all valid vulnerability type IDs.

    Returns:
        List of all registered vulnerability type IDs
    """
    return list(VULNERABILITY_TYPE_REGISTRY.keys())


def validate_vulnerability_type(type_id: str) -> tuple[bool, str | None]:
    """Validate that a vulnerability type ID is valid.

    Args:
        type_id: Vulnerability type identifier to validate

    Returns:
        Tuple of (is_valid, error_message)
    """
    if type_id in VULNERABILITY_TYPE_REGISTRY:
        return True, None
    valid_types = ", ".join(sorted(VULNERABILITY_TYPE_REGISTRY.keys()))
    return False, f"Invalid vulnerability type '{type_id}'. Valid types: {valid_types}"
